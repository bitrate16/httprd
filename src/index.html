<html>
	<head>
		<title>HTTPRD</title>
		<meta charset="UTF-8">
		<style>
			canvas {
				width: 100%;
				height: 100%;
			}

			* {
				font-family: monospace;
				font-weight: bold;
			}

			html, body {
				width: 100%;
				height: 100%;
				padding: 0;
				margin: 0;
			}

			#dialog {
				position: absolute;
				width: 100%;
				height: 100%;
				z-index: 900;
				top: 0;
				left: 0;

				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
			}

			#dialog > #shadow {
				position: absolute;
				width: 100%;
				height: 100%;
				z-index: 910;
				top: 0;
				left: 0;
				background-color: #0007;
			}

			#dialog > #content {
				z-index: 920;
				padding: 1rem;
				background-color: #fff;
			}

			#dialog > #content > #title {
				font-size: 1.5rem;
				margin-bottom: 0.5rem;
			}

			#dialog > #content > #form {
				width: 100%;
			}

			div.input-field {
				display: flex;
				flex-direction: row;
				flex-wrap: nowrap;
				justify-content: space-between;
				width: calc(100% - 1rem);
				border: thin solid #aaf;
				padding: 0.5rem;
				margin-bottom: 0.5rem;
			}

			div.input-field > label {
				padding: 0.25rem;
			}

			div.input-field > div {
				display: flex;
				flex-direction: row;
				flex-wrap: nowrap;
				gap: 0.5rem;
			}

			div.input-field > div > input {
				background-color: #eee;
				border: thin solid #aaf;
				box-sizing: border-box;
				padding: 0.25rem;
			}

			div.input-field > div > input:hover {
				box-shadow: #77f 0px 0px 0px 0.1rem;
				opacity: 0.75;
			}

			div.input-field > div > input:active {
				border: thin solid #77f;
			}

			div.input-field > div > input[type="button"]:active {
				background-color: #77e;
			}

            #netstat {
                position: absolute;
                /* width: 1rem; */
                height: 1rem;
                bottom: 1rem;
                left: 1rem;
                overflow: hidden;
                font-size: 1rem;
                user-select: none;
                color: #000;
                text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
            }

            #config {
                position: absolute;
                width: 1rem;
                height: 1rem;
                bottom: 1rem;
                right: 1rem;
                overflow: hidden;
                font-size: 1rem;
                cursor: pointer;
                user-select: none;
                color: #000;
                text-shadow: -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff, 1px 1px 0 #fff;
            }
		</style>
	</head>
	<body>
		<canvas id="display">
		</canvas>
		<div id="dialog" style="display:none;">
			<div id="content">
				<div id="title">
					Config
				</div>
				<div id="form">
				</div>
			</div>
			<div id="shadow" onclick="hideConfigDialog();"></div>
		</div>
		<div id="netstat"></div>
		<div id="config" onclick="showConfigDialog();">âš™</div>
		<script type="text/javascript" async>
			(async function () {

				// Cookies access

				function getCookie(name) {
					const value = `; ${document.cookie}`;
					const parts = value.split(`; ${name}=`);
					if (parts.length === 2)
						return parts.pop().split(';').shift();
					return null;
				}

				function setCookie(cname, cvalue) {
					const d = new Date();
					d.setTime(d.getTime() + (36500 * 24 * 60 * 60 * 1000));
					let expires = "expires="+ d.toUTCString();
					document.cookie = `${ cname }=${ cvalue };${ expires };path=/;domain=.${ window.location.hostname }`;
				}


				// UI elements

				function showToast(text, duration, appearDuration) {
					console.info(text);

					if (duration <= 0)
						throw new Error('Invalid value for duration');

					if (appearDuration <= 0)
						throw new Error('Invalid value for appearDuration');

					// Wrapper for centering
					var element = document.createElement('div');
					element.style.cssText = `
						position: fixed;
						transition: opacity ${ appearDuration }s, bottom ${ appearDuration }s ease-in-out;
						pointer-events: none;
						user-select: none;
						left: 1rem;
						opacity: 0;
						bottom: -3rem;
					`;

					var inner = document.createElement('div');
					inner.style.cssText = `
						pointer-events: none;
						user-select: none;
						font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
						font-size: 1rem;
						padding: 0.5rem;
						line-height: calc(1rem - 0.2rem);
						box-sizing: border-box;
						background-color: white;
						border: 0.1rem solid #77f;
						color: #77f;
						font-weight: bold;
						text-align: center;
						margin-left: auto;
						margin-right: auto;
					`;
					inner.textContent = text;

					element.appendChild(inner);
					document.body.appendChild(element);

					// Wait & show
					getComputedStyle(element).opacity;
					element.style.bottom = '1rem';
					element.style.opacity = '1';

					// Appear + visible delay
					setTimeout(function () {
						// Make transparent and hide
						element.style.bottom = '-3rem';
						element.style.opacity = '0';

						setTimeout(function () {
							// Dispose
							document.body.removeChild(element);
						}, appearDuration * 1000);
					}, appearDuration * 1000 + duration * 1000);
				}

				function htmlToElement(html) {
					var template = document.createElement('template');
					html = html.trim();
					template.innerHTML = html;
					return template.content.firstChild;
				};

				async function hideConfigDialog() {
                    await app.startConnection();
					document.getElementById('dialog').style.display='none';
				}

				async function showConfigDialog() {
                    await app.stopConnection();

					document.getElementById('dialog').style.display=null;
					var form = document.getElementById('form');
					form.innerHTML = '';

					for (const [key, value] of Object.entries(getProps())) {
						var element = htmlToElement(`
						<div class="input-field">
							<label>${ key }</label>
							<div>
								<input type="text" value="${ value }" id="input-${ key }">
								<input type="button" value="set" id="submit-${ key }">
							</div>
						</div>`);

						form.appendChild(element);
						document.querySelector(`#submit-${ key }`).addEventListener('click', function () {
							let newValue = document.querySelector(`#input-${ key }`).value.trim();
							setProp(key, newValue);
							showToast(`Set value for ${ key }`, 1, 1);
						});
					}
				}

				// Bind to global
				window.showConfigDialog = showConfigDialog;
				window.hideConfigDialog = hideConfigDialog;


				// Convert bytes

				function decode_int8(data, off) {
					return data[off];
				}

				function decode_int16(data, off) {
					return data[off] | (data[off + 1] << 8);
				}

				function decode_int24(data, off) {
					return data[off] | (data[off + 1] << 8) | (data[off + 2] << 16);
				}

				function encode_int8(i, arr, off) {
					arr[off] = i & 0xff;
				}

				function encode_int16(i, arr, off) {
					arr[off] = i & 0xff;
					arr[off + 1] = (i >> 8) & 0xff;
				}

				function encode_int24(i, arr, off) {
					arr[off] = i & 0xff;
					arr[off + 1] = (i >> 8) & 0xff;
					arr[off + 2] = (i >> 16) & 0xff;
				}


				// Local app state
				var app = {};


				// Socket + loop state
				app.viewSocket = null;
				app.workerLoopTs = 0;
				app.workerLoopShouldRun = false;


				// Default app.props
				const DEFAULT_PROPS = {
					'password': '',
					'quality': 50,
					'fps': 20,
					'ips': 5
				};

				app.props = null;


				// props access
				function initProps() {
					app.props = { ...DEFAULT_PROPS };

					try {
						var localProps = JSON.parse(localStorage.getItem('httprd-app.props'));
						for (const [key, _] of Object.entries(app.props)) {
							var v = localProps[key];
							if (v)
								app.props[key] = v;
						}
					} catch {}
				};

				function getProp(name) {
					return app.props[name];
				};

				function getProps() {
					return app.props;
				}

				function setProp(name, value) {
					if (name === 'password') {
						value = value.trim();
					} else if (name === 'quality') {
						try {
							value = parseInt(value);
						} catch (e) {
							throw new Error('quality must be in range [1, 100]');
						}

						if (value < 1 || value > 100)
							throw new Error('quality must be in range [1, 100]');
					} else if (name === 'fps') {
						try {
							value = parseInt(value);
						} catch (e) {
							throw new Error('fps must be in range [1, inf]');
						}

						if (value < 1)
							throw new Error('fps must be in range [1]');
					} else if (name === 'ips') {
						try {
							value = parseInt(value);
						} catch (e) {
							throw new Error('ips must be in range [1, inf]');
						}

						if (value < 1)
							throw new Error('ips must be in range [1]');
					}

					app.props[name] = value;
					localStorage.setItem('httprd-app.props', JSON.stringify(app.props));
				};

				initProps();


                // Canvas + ctx
				app.canvas = document.getElementById('display');
				app.canvasContext = app.canvas.getContext('2d');


                // Network status view
                var netstatElement = document.querySelector('#netstat');

                // Connecion activator based on promise
                app.startConnection = async function() {

                    console.log('startConnection() : enter');

                    // Prevent stacking
                    if (app.isConnectionRunning) {
                        console.log('startConnection() : unstack');

                        return;
                    }

                    // Indicate this thread as self-reconnectable
                    app.keepAlive = true;
                    app.viewPromise = null;
                    app.inputPromise = null;

					// Clear dimensions of desktop
					app.remote = { width: 0, height: 0 };
					app.viewport = { width: 0, height: 0 };

                    // Flag if started
                    app.isConnectionRunning = true;

                    // Clear network status
                    netstatElement.textContent = '';

                    // Start view connection
                    app.viewPromise = new Promise((resolve, _) => {

                        // Indicate if toasted access error
                        var hasShownPasswordError = false;

                        // Create connection to the view mode thread
                        var makeViewConnection = function() {

                            // Send frame request to server
                            var lastFrameRequestTS = null;
                            var requestFrame = function () {

                                // Exit all handlers/coroutines if they were called after socket close
                                if (!app.keepAlive || mySocketRef.readyState === WebSocket.CLOSED) {
                                    try {
                                        mySocketRef.close();
                                    } catch {}
                                    return;
                                }

                                var requestFrame__buffer = new Uint8Array(1 + 2 + 2 + 1);

                                try {
                                    // Send packet type
                                    encode_int8(0x01, requestFrame__buffer, 0);

                                    // Send width & height
                                    let viewport_width = Math.max(Math.min(window.innerWidth, 65535), 1);
                                    let viewport_height = Math.max(Math.min(window.innerHeight, 65535), 1);
                                    let quality = Math.max(Math.min(getProp('quality'), 100), 1);
                                    encode_int16(viewport_width, requestFrame__buffer, 1);
                                    encode_int16(viewport_height, requestFrame__buffer, 3);
                                    encode_int8(quality, requestFrame__buffer, 5);

                                    // Actually, send
                                    lastFrameRequestTS = Date.now();
                                    mySocketRef.send(requestFrame__buffer.buffer);
                                } catch (e) {
                                    console.error(e);
                                }

                                delete requestFrame__buffer;
                            };

                            var updateSize = function () {
                                // Resize canvas
                                if (app.canvas.width != window.innerWidth || app.canvas.height != window.innerHeight) {
                                    app.canvas.width = window.innerWidth;
                                    app.canvas.height = window.innerHeight;

                                    // Update app.props for view
                                    app.lineHeight = window.getComputedStyle(document.body).lineHeight;
                                    app.pageHeight = window.clientHeight;
                                }
                            };

                            // Interframe delay based on props, props can not be changed during active session
                            var interframeDelay = 1000.0 / getProp('fps');

                            function viewSocketMessageHandler(msg) {

                                // Exit all handlers/coroutines if they were called after socket close
                                if (!app.keepAlive || mySocketRef.readyState === WebSocket.CLOSED) {
                                    try {
                                        mySocketRef.close();
                                    } catch {}
                                    return;
                                }

                                // Typed messages
                                if (msg.data instanceof ArrayBuffer) {
                                    var data = new Uint8Array(msg.data);
                                    var packet_type = decode_int8(data, 0);

                                    // Frame
                                    if (packet_type == 0x02) {

                                        // Frame request RTT
                                        var frameRTT = Date.now() - lastFrameRequestTS;

                                        // Update network status
                                        netstatElement.textContent = `${ frameRTT }ms`;

                                        try {
                                            // Update remote desktop properties
                                            app.remote.width = decode_int16(data, 1);
                                            app.remote.height = decode_int16(data, 3);
                                            var frame_type = decode_int8(data, 5);

                                            // Ignore empty frames
                                            if (data.length === 6 || frame_type === 0x00) {

                                                // Request new frame with respect to frame RTT in interframe FPS delay
                                                if (interframeDelay * 2.0 <= frameRTT)
                                                    requestFrame();
                                                else
                                                    setTimeout(requestFrame, interframeDelay * 2.0 - frameRTT);

                                            // Full redraw
                                            } else if (frame_type === 0x01) {

                                                // Get frame blob
                                                var blob = new Blob([ data.slice(6) ], { type: 'image/jpeg' });
                                                var url = URL.createObjectURL(blob);

                                                // Deallocate
                                                delete blob;

                                                var frame = new Image();
                                                frame.onload = function () {

                                                    // Extract JPEG as base64 or sth similar
                                                    URL.revokeObjectURL(url);

                                                    // Update canvas size if required
                                                    updateSize();

                                                    app.canvasContext.drawImage(
                                                        frame,
                                                        app.canvas.width / 2 - frame.width / 2,
                                                        app.canvas.height / 2 - frame.height / 2
                                                    );

                                                    // Received frame size
                                                    app.viewport.width = frame.width;
                                                    app.viewport.height = frame.height;

                                                    // Release
                                                    delete frame;

                                                    // Request new frame with respect to frame RTT in interframe FPS delay
                                                    if (interframeDelay <= frameRTT)
                                                        requestFrame();
                                                    else
                                                        setTimeout(requestFrame, interframeDelay - frameRTT);
                                                };
                                                frame.src = url;

                                            // Partial redraw
                                            } else if (frame_type === 0x02) {

                                                var crop_x = decode_int16(data, 6);
                                                var crop_y = decode_int16(data, 8);

                                                // Get frame blob
                                                var blob = new Blob([ data.slice(10) ], { type: 'image/jpeg' });
                                                var url = URL.createObjectURL(blob);

                                                // Deallocate
                                                delete blob;

                                                var frame = new Image();
                                                frame.onload = function () {

                                                    URL.revokeObjectURL(url);

                                                    // Update canvas size if required
                                                    updateSize();

                                                    app.canvasContext.drawImage(
                                                        frame,
                                                        app.canvas.width / 2 - app.viewport.width / 2 + crop_x,
                                                        app.canvas.height / 2 - app.viewport.height / 2 + crop_y
                                                    );

                                                    // Release
                                                    delete frame;

                                                    // Request new frame with respect to frame RTT in interframe FPS delay
                                                    if (interframeDelay <= frameRTT)
                                                        requestFrame();
                                                    else
                                                        setTimeout(requestFrame, interframeDelay - frameRTT);
                                                };
                                                frame.src = url;
                                            }
                                        } catch (e) {

                                            console.error(e);

                                            // Request new frame with respect to frame RTT in interframe FPS delay
                                            if (interframeDelay <= frameRTT)
                                                requestFrame();
                                            else
                                                setTimeout(requestFrame, interframeDelay - frameRTT);
                                        }
                                    }

                                    // Deallocate
                                    delete data;
                                }
                            };

                            // Clean password error timeout if session haven't died
                            var passwordErrorTimeout = null;

                            // Set title second after connect
                            var titleSetTimeout = null;

                            function viewSocketOpenHandler(event) {

                                // Exit all handlers/coroutines if they were called after socket close
                                if (!app.keepAlive || mySocketRef.readyState === WebSocket.CLOSED) {
                                    try {
                                        mySocketRef.close();
                                    } catch {}
                                    return;
                                }

                                // No password error
                                passwordErrorTimeout = setTimeout(function() { hasShownPasswordError = false; }, 1000);
                                titleSetTimeout = setTimeout(function() { document.title = 'HTTPRD (Connected)'; }, 1000);

                                // Start frame requesting
                                requestFrame();
                            };

                            function viewSocketCloseHandler(event) {

                                // Toast.makeText
                                if (event.code === 4001) {
                                    if (!hasShownPasswordError)
                                        showToast('No access to input', 1, 1);

                                    // Now we have problems with password
                                    clearTimeout(passwordErrorTimeout);
                                    hasShownPasswordError = true;
                                } else
                                    showToast('Input connection closed', 1, 1);

                                // Undo setting title
                                clearTimeout(titleSetTimeout);
                                document.title = 'HTTPRD (Disconnected)';

                                if (app.keepAlive) {

                                    // Restart after 5 seconds
                                    setTimeout(function() {

                                        // Exit all handlers/coroutines if they were called after socket close
                                        if (!app.keepAlive)
                                            // Exit promise worker
                                            resolve();
                                        else
                                            // rekonnekt
                                            makeViewConnection();

                                    // Delay based on status code
                                    }, (event.code === 4001) ? 5000 : 1000);

                                } else
                                    // Exit promise worker
                                    resolve();
                            };

                            console.info('connect to', `${ window.location.protocol === 'https:' ? 'wss' : 'ws' }://${ window.location.host }/connect_view_ws`)
                            var mySocketRef = new WebSocket(`${ window.location.protocol === 'https:' ? 'wss' : 'ws' }://${ window.location.host }/connect_view_ws?password=${ encodeURIComponent(getProp('password')) }`);
                            mySocketRef.binaryType = 'arraybuffer';
                            mySocketRef.onmessage = viewSocketMessageHandler;
                            mySocketRef.onopen = viewSocketOpenHandler;
                            mySocketRef.onclose = viewSocketCloseHandler;
                            app.viewSocket = mySocketRef;
                        };

                        // konnekt
                        makeViewConnection();

                    });

                    // Start input connection
                    app.inputPromise = new Promise((resolve, _) => {

                        // Indicate if toasted access error
                        var hasShownPasswordError = false;

                        // Create connection to the view mode thread
                        var makeInputConnection = function() {

                            var ts = Date.now() % 100;

                            function inputSocketMessageHandler(msg) {

                                // Exit all handlers/coroutines if they were called after socket close
                                if (!app.keepAlive) {
                                    try {
                                        app.viewSocket.close();
                                    } catch {}
                                }

                                // Typed messages
                                if (msg.data instanceof ArrayBuffer) {
                                    var data = new Uint8Array(msg.data);
                                    var packet_type = decode_int8(data, 0);

                                    // Deallocate
                                    delete data;
                                }
                            };

                            // Clean password error timeout if session haven't died
                            var passwordErrorTimeout = null;

                            function inputSocketOpenHandler(event) {

                                // Exit all handlers/coroutines if they were called after socket close
                                if (!app.keepAlive || mySocketRef.readyState === WebSocket.CLOSED) {
                                    try {
                                        mySocketRef.close();
                                    } catch {}
                                    return;
                                }

                                // No password error
                                passwordErrorTimeout = setTimeout(function() { hasShownPasswordError = false; }, 5000);

                                // Do attachment of sender
                                startInputLoop();
                            };

                            function inputSocketCloseHandler(event) {

                                // Detach handlers
                                stopInputLoop();

                                // Toast.makeText
                                if (event.code === 4001) {
                                    if (!hasShownPasswordError)
                                        showToast('No access to input', 1, 1);

                                    // Now we have problems with password
                                    clearTimeout(passwordErrorTimeout);
                                    hasShownPasswordError = true;
                                } else
                                    showToast('Input connection closed', 1, 1);

                                if (app.keepAlive) {

                                    // Restart after 5 seconds
                                    setTimeout(function() {

                                        // Exit all handlers/coroutines if they were called after socket close
                                        if (!app.keepAlive) {
                                            // Exit promise worker
                                            resolve();
                                        } else
                                            // rekonnekt
                                            makeInputConnection();

                                    // Delay based on status code
                                    }, (event.code === 4001) ? 5000 : 1000);

                                } else
                                    // Exit promise worker
                                    resolve();
                            };

                            console.info('connect to', `${ window.location.protocol === 'https:' ? 'wss' : 'ws' }://${ window.location.host }/connect_input_ws`)
                            var mySocketRef = new WebSocket(`${ window.location.protocol === 'https:' ? 'wss' : 'ws' }://${ window.location.host }/connect_input_ws?password=${ encodeURIComponent(getProp('password')) }`);
                            mySocketRef.binaryType = 'arraybuffer';
                            mySocketRef.onmessage = inputSocketMessageHandler;
                            mySocketRef.onopen = inputSocketOpenHandler;
                            mySocketRef.onclose = inputSocketCloseHandler;
                            app.inputSocket = mySocketRef;

                            // Input event types
                            const INPUT_EVENT_MOUSE_MOVE   = 0;
                            const INPUT_EVENT_MOUSE_DOWN   = 1;
                            const INPUT_EVENT_MOUSE_UP     = 2;
                            const INPUT_EVENT_MOUSE_SCROLL = 3;
                            const INPUT_EVENT_KEY_DOWN     = 4;
                            const INPUT_EVENT_KEY_UP       = 5;

                            // Map JS kkode to pyautogui
                            const jsToPyKeys = {
                                "Quote": "'",
                                "Plus": "+",
                                "Comma": ",",
                                "Minus": "-",
                                "Period": ".",
                                "Slash": "/",
                                "Digit0": "0",
                                "Digit1": "1",
                                "Digit2": "2",
                                "Digit3": "3",
                                "Digit4": "4",
                                "Digit5": "5",
                                "Digit6": "6",
                                "Digit7": "7",
                                "Digit8": "8",
                                "Digit9": "9",
                                "Semicolon": ";",
                                "Equal": "=",
                                "BracketLeft": "[",
                                "Backslash": "\\",
                                "BracketRight": "]",
                                "Backquote": "`",
                                "KeyA": "a",
                                "KeyB": "b",
                                "KeyC": "c",
                                "KeyD": "d",
                                "KeyE": "e",
                                "KeyF": "f",
                                "KeyG": "g",
                                "KeyH": "h",
                                "KeyI": "i",
                                "KeyJ": "j",
                                "KeyK": "k",
                                "KeyL": "l",
                                "KeyM": "m",
                                "KeyN": "n",
                                "KeyO": "o",
                                "KeyP": "p",
                                "KeyQ": "q",
                                "KeyR": "r",
                                "KeyS": "s",
                                "KeyT": "t",
                                "KeyU": "u",
                                "KeyV": "v",
                                "KeyW": "w",
                                "KeyX": "x",
                                "KeyY": "y",
                                "KeyZ": "z",
                                "NumpadAdd": "add",
                                "AltLeft": "altleft",
                                "AltRight": "altright",
                                "Backspace": "backspace",
                                "BrowserBack": "browserback",
                                "BrowserFavourites": "browserfavorites",
                                "BrowserForward": "browserforward",
                                "BrowserHome": "browserhome",
                                "BrowserRefresh": "browserrefresh",
                                "BrowserSearch": "browsersearch",
                                "BrowserStop": "browserstop",
                                "CapsLock": "capslock",
                                "Convert": "convert",
                                "ControlLeft": "ctrlleft",
                                "ControlRight": "ctrlright",
                                "NumpadDecimal": "decimal",
                                "Delete": "delete",
                                "NumpadDivide": "divide",
                                "ArrowDown": "down",
                                "End": "end",
                                "Enter": "enter",
                                "Escape": "escape",
                                "F1": "f1",
                                "F2": "f2",
                                "F3": "f3",
                                "F4": "f4",
                                "F5": "f5",
                                "F6": "f6",
                                "F7": "f7",
                                "F8": "f8",
                                "F9": "f9",
                                "F10": "f10",
                                "F11": "f11",
                                "F12": "f12",
                                "F13": "f13",
                                "F14": "f14",
                                "F15": "f15",
                                "F16": "f16",
                                "F17": "f17",
                                "F18": "f18",
                                "F19": "f19",
                                "F20": "f20",
                                "F21": "f21",
                                "F22": "f22",
                                "F23": "f23",
                                "F24": "f24",
                                "Fn": "fn",
                                "Help": "help",
                                "Home": "home",
                                "Insert": "insert",
                                "KanaMode": "kana",
                                "LaunchApp1": "launchapp1",
                                "LaunchApp2": "launchapp2",
                                "LaunchMail": "launchmail",
                                "MediaSelect": "launchmediaselect",
                                "ArrowLeft": "left",
                                "NumpadMultiply": "multiply",
                                "MediaTrackNext": "nexttrack",
                                "NonConvert": "nonconvert",
                                "Numpad0": "num0",
                                "Numpad1": "num1",
                                "Numpad2": "num2",
                                "Numpad3": "num3",
                                "Numpad4": "num4",
                                "Numpad5": "num5",
                                "Numpad6": "num6",
                                "Numpad7": "num7",
                                "Numpad8": "num8",
                                "Numpad9": "num9",
                                "NumLock": "numlock",
                                "PageDown": "pagedown",
                                "PageUp": "pageup",
                                "Pause": "pause",
                                "MediaPlayPause": "playpause",
                                "MediaTrackPrevious": "prevtrack",
                                "Print": "print",
                                "PrintScreen": "printscreen",
                                "ArrowRight": "right",
                                "ScrollLock": "scrolllock",
                                "Select": "select",
                                "ShiftLeft": "shiftleft",
                                "ShiftRight": "shiftright",
                                "Sleep": "sleep",
                                "Space": "space",
                                "MediaStop": "stop",
                                "NumpadSubtract": "subtract",
                                "Tab": "tab",
                                "ArrowUp": "up",
                                "AudioVolumeDown": "volumedown",
                                "VolumeDown": "volumedown",
                                "AudioVolumeMute": "volumemute",
                                "AudioVolumeUp": "volumeup",
                                "VolumeUp": "volumeup",
                                "OSLeft": "winleft",
                                "MetaLeft": "winleft",
                                "OSRight": "winright",
                                "MetaRight": "winright",
                                "IntlYen": "yen",
                            };

                            // Bug/Feature: ShiftLeft up not triggered if ShiftRight is pressed, and vice versa
                            // Solution: Fire release for both keys
                            var ShiftLeftPressed = false;
                            var ShiftRightPressed = false;

                            var inputEvents = [];
                            var lastInputTs = Date.now();

                            // Mouse move handler: throttle to ips
                            var lastMouseMoveTs = Date.now();
                            mouseMoveEventHandler = function (event) {

                                // Fire only inside viewbox & with throttling to ips
                                var currentMouseMoveTs = Date.now();
                                if (
                                    app.viewport.width === 0 ||
                                    app.viewport.height === 0 ||
                                    currentMouseMoveTs - lastMouseMoveTs < 1000.0 / getProp('ips')
                                ) return;

                                let rectX = (app.canvas.clientWidth / 2) - (app.viewport.width / 2);
                                let rectY = (app.canvas.clientHeight / 2) - (app.viewport.height / 2);

                                if (
                                    event.pageX >= rectX && event.pageX <= rectX + app.viewport.width &&
                                    event.pageY >= rectY && event.pageY <= rectY + app.viewport.height
                                ) {
                                    let realX = Math.round((event.pageX - rectX) * app.remote.width / app.viewport.width);
                                    let realY = Math.round((event.pageY - rectY) * app.remote.height / app.viewport.height);

                                    inputEvents.push([
                                        INPUT_EVENT_MOUSE_MOVE,
                                        realX,
                                        realY
                                    ]);

                                    lastMouseMoveTs = currentMouseMoveTs;
                                }
                            };

                            // Mouse scroll handler: throttle to ips
                            var lastMouseScrollTs = Date.now();
                            mouseScrollEventHandler = function (event) {

                                // Fire only inside viewbox & with throttling to ips
                                var currentMouseScrollTs = Date.now();
                                if (
                                    app.viewport.width === 0 ||
                                    app.viewport.height === 0 ||
                                    currentMouseScrollTs - lastMouseScrollTs < 1000.0 / getProp('ips')
                                ) return;

                                let rectX = (app.canvas.clientWidth / 2) - (app.viewport.width / 2);
                                let rectY = (app.canvas.clientHeight / 2) - (app.viewport.height / 2);

                                if (
                                    event.pageX >= rectX && event.pageX <= rectX + app.viewport.width &&
                                    event.pageY >= rectY && event.pageY <= rectY + app.viewport.height
                                ) {
                                    let realX = Math.round((event.pageX - rectX) * app.remote.width / app.viewport.width);
                                    let realY = Math.round((event.pageY - rectY) * app.remote.height / app.viewport.height);

                                    inputEvents.push([
                                        INPUT_EVENT_MOUSE_SCROLL,
                                        realX,
                                        realY,
                                        -event.deltaY
                                    ]);

                                    lastMouseScrollTs = currentMouseScrollTs;
                                }
                            };

                            // Mouse down handler: no throttle
                            mouseDownEventHandler = function (event) {

                                // Stop event
                                event.preventDefault();
                                event.stopPropagation();

                                // Check
                                if (app.remote.width === 0 || app.remote.height === 0)
                                    return;

                                let rectX = (app.canvas.clientWidth / 2) - (app.viewport.width / 2);
                                let rectY = (app.canvas.clientHeight / 2) - (app.viewport.height / 2);

                                if (
                                    event.pageX >= rectX && event.pageX <= rectX + app.viewport.width &&
                                    event.pageY >= rectY && event.pageY <= rectY + app.viewport.height
                                ) {
                                    let realX = Math.round((event.pageX - rectX) * app.remote.width / app.viewport.width);
                                    let realY = Math.round((event.pageY - rectY) * app.remote.height / app.viewport.height);

                                    inputEvents.push([
                                        INPUT_EVENT_MOUSE_DOWN,
                                        realX,
                                        realY,
                                        event.button,
                                    ]);
                                }
                            };

                            // Mouse up handler: no throttle
                            mouseUpEventHandler = function (event) {

                                // Stop event
                                event.preventDefault();
                                event.stopPropagation();

                                // Check
                                if (app.remote.width === 0 || app.remote.height === 0)
                                    return;

                                let rectX = (app.canvas.clientWidth / 2) - (app.viewport.width / 2);
                                let rectY = (app.canvas.clientHeight / 2) - (app.viewport.height / 2);

                                let realX = Math.round((event.pageX - rectX) * app.remote.width / app.viewport.width);
                                let realY = Math.round((event.pageY - rectY) * app.remote.height / app.viewport.height);

                                inputEvents.push([
                                    INPUT_EVENT_MOUSE_UP,
                                    realX,
                                    realY,
                                    event.button,
                                ]);
                            };

                            // Context menu suppress
                            contextMenuCancelEventHandler = function (event) {
                                event.preventDefault();
                                event.stopPropagation();
                                return false;
                            };

                            // Key down handler: throttle to ips
                            var lastKeyDownTs = Date.now();
                            keyDownEventHandler = function (event) {

                                // Stop event
                                event.preventDefault();
                                event.stopPropagation();

                                ShiftLeftPressed = ShiftLeftPressed || event.code === 'ShiftLeft';
                                ShiftRightPressed = ShiftRightPressed || event.code === 'ShiftRight';

                                // Prevent repetitive events spamming
                                var currentKeyDownTs = Date.now();
                                if (event.repeat && currentKeyDownTs - lastKeyDownTs < 1000.0 / getProp('ips'))
                                    return;

                                if (event.code in jsToPyKeys) {
                                    inputEvents.push([
                                        INPUT_EVENT_KEY_DOWN,
                                        jsToPyKeys[event.code]
                                    ]);

                                    lastKeyDownTs = currentKeyDownTs;
                                }

                                return false;
                            };

                            // Key up handler: no throttle
                            keyUpEventHandler = function (event) {

                                // Stop event
                                event.preventDefault();
                                event.stopPropagation();

                                if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {
                                    if (ShiftLeftPressed) {
                                        inputEvents.push([
                                            INPUT_EVENT_KEY_UP,
                                            jsToPyKeys['ShiftLeft']
                                        ]);
                                    }

                                    if (ShiftRightPressed) {
                                        inputEvents.push([
                                            INPUT_EVENT_KEY_UP,
                                            jsToPyKeys['ShiftRight']
                                        ]);
                                    }

                                    lastMouseScrollTs = Date.now();

                                } else if (event.code in jsToPyKeys) {
                                    inputEvents.push([
                                        INPUT_EVENT_KEY_UP,
                                        jsToPyKeys[event.code]
                                    ]);

                                    lastMouseScrollTs = Date.now();
                                }

                                return false;
                            };

                            // Attach handlers & start deferred sender
                            function startInputLoop() {

                                console.log('startInputLoop() : starting input loop');

                                // Register listeners
                                app.canvas.addEventListener('mousemove', mouseMoveEventHandler);
                                app.canvas.addEventListener('wheel', mouseScrollEventHandler);
                                app.canvas.addEventListener('mousedown', mouseDownEventHandler);
                                app.canvas.addEventListener('mouseup', mouseUpEventHandler);
                                app.canvas.addEventListener('contextmenu', contextMenuCancelEventHandler);

                                document.addEventListener('keydown', keyDownEventHandler);
                                document.addEventListener('keyup', keyUpEventHandler);

                                // Input publisher
                                var pushInput = function () {

                                    // Exit all handlers/coroutines if they were called after socket close
                                    if (!app.keepAlive || mySocketRef.readyState === WebSocket.CLOSED) {
                                        try {
                                            mySocketRef.close();
                                        } catch {}
                                        return;
                                    }

                                    try {
                                        if (inputEvents.length) {
                                            var inputEvents_ = inputEvents;
                                            inputEvents_ = inputEvents;
                                            inputEvents = [];

                                            var serialized = JSON.stringify(inputEvents_);
                                            var requestInput__buffer = new Uint8Array(1 + serialized.length);

                                            // Send packet type
                                            encode_int8(0x03, requestInput__buffer, 0);

                                            // Send data
                                            for (let ind = 0; ind < serialized.length; ++ind)
                                                requestInput__buffer[ind + 1] = serialized.charCodeAt(ind);

                                            // Actually, send
                                            mySocketRef.send(requestInput__buffer.buffer);
                                            lastInputTs = Date.now();

                                            delete requestInput__buffer;
                                        }
                                    } catch (e) {
                                        console.error(e);
                                    }
                                    setTimeout(pushInput, 1000.0 / getProp('ips'));
                                };
                                setTimeout(pushInput, 1000.0 / getProp('ips'));
                            };

                            // Detach all handlers & clear event queue
                            function stopInputLoop() {
                                console.info('stopInputLoop() : stopping input loop');

                                app.canvas.removeEventListener('mousemove', mouseMoveEventHandler);
                                app.canvas.removeEventListener('wheel', mouseScrollEventHandler);
                                app.canvas.removeEventListener('mousedown', mouseDownEventHandler);
                                app.canvas.removeEventListener('mouseup', mouseUpEventHandler);
                                app.canvas.removeEventListener('contextmenu', contextMenuCancelEventHandler);

                                document.removeEventListener('keydown', keyDownEventHandler);
                                document.removeEventListener('keyup', keyUpEventHandler);

                                inputEvents = [];
                            };
                        };

                        // konnekt
                        makeInputConnection();

                    });

                    console.log('startConnection() : exit');

                };

                app.stopConnection = async function() {

                    console.log('stopConnection() : enter');

                    // Disable self-reconnect
                    app.keepAlive = false;

                    // Wait for promises to exit based on keepAlive flag
                    await app.viewPromise;
                    await app.inputPromise;

                    // Not running anymore, can start
                    app.isConnectionRunning = false;

                    // Clear network status
                    netstatElement.textContent = '';

                    console.log('stopConnection() : exit');
                };

                app.startConnection();
			}) ();
		</script>
	</body>
</html>

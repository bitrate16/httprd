<html>
	<head>
		<title>HTTPRD</title>
		<meta charset="UTF-8">
		<style>
			canvas {
				width: 100%;
				height: 100%;
			}

			* {
				font-family: monospace;
				font-weight: bold;
			}

			html, body {
				width: 100%;
				height: 100%;
				padding: 0;
				margin: 0;
			}

			#dialog {
				position: absolute;
				width: 100%;
				height: 100%;
				z-index: 900;
				top: 0;
				left: 0;

				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
			}

			#dialog > #shadow {
				position: absolute;
				width: 100%;
				height: 100%;
				z-index: 910;
				top: 0;
				left: 0;
				background-color: #0007;
			}

			#dialog > #content {
				z-index: 920;
				padding: 1rem;
				background-color: #fff;
			}

			#dialog > #content > #title {
				font-size: 1.5rem;
				margin-bottom: 0.5rem;
			}

			#dialog > #content > #form {
				width: 100%;
			}

			div.input-field {
				display: flex;
				flex-direction: row;
				flex-wrap: nowrap;
				justify-content: space-between;
				width: calc(100% - 1rem);
				border: thin solid #aaf;
				padding: 0.5rem;
				margin-bottom: 0.5rem;
			}

			div.input-field > label {
				padding: 0.25rem;
			}

			div.input-field > div {
				display: flex;
				flex-direction: row;
				flex-wrap: nowrap;
				gap: 0.5rem;
			}

			div.input-field > div > input {
				background-color: #eee;
				border: thin solid #aaf;
				box-sizing: border-box;
				padding: 0.25rem;
			}

			div.input-field > div > input:hover {
				box-shadow: #77f 0px 0px 0px 0.1rem;
				opacity: 0.75;
			}

			div.input-field > div > input:active {
				border: thin solid #77f;
			}

			div.input-field > div > input[type="button"]:active {
				background-color: #77e;
			}

			#config {
				position: absolute;
				width: 1rem;
				height: 1rem;
				bottom: 1rem;
				right: 1rem;
				overflow: hidden;
				font-size: 1rem;
				cursor: pointer;
				user-select: none;
			}
		</style>
	</head>
	<body>
		<canvas id="display">
		</canvas>
		<div id="dialog" style="display:none;">
			<div id="content">
				<div id="title">
					Config
				</div>
				<div id="form">
				</div>
			</div>
			<div id="shadow" onclick="hideConfigDialog();"></div>
		</div>
		<div id="config" onclick="showConfigDialog();">âš™</div>
		<script type="text/javascript" async>

			const INPUT_EVENT_MOUSE_MOVE   = 0;
			const INPUT_EVENT_MOUSE_DOWN   = 1;
			const INPUT_EVENT_MOUSE_UP     = 2;
			const INPUT_EVENT_MOUSE_SCROLL = 3;

			function getCookie(name) {
				const value = `; ${document.cookie}`;
				const parts = value.split(`; ${name}=`);
				if (parts.length === 2)
					return parts.pop().split(';').shift();
				return null;
			}

			function setCookie(cname, cvalue) {
				const d = new Date();
				d.setTime(d.getTime() + (36500 * 24 * 60 * 60 * 1000));
				let expires = "expires="+ d.toUTCString();
				document.cookie = `${ cname }=${ cvalue };${ expires };path=/;domain=.${ window.location.hostname }`;
			}

			function showToast(text, duration, appearDuration) {
				console.error(text)
				if (duration <= 0)
					throw new Error('Invalid value for duration');

				if (appearDuration <= 0)
					throw new Error('Invalid value for appearDuration');

				// Wrapper for centering
				var element = document.createElement('div');
				element.style.cssText = `
					position: fixed;
					transition: opacity ${ appearDuration }s, bottom ${ appearDuration }s ease-in-out;
					pointer-events: none;
					user-select: none;
					left: 1rem;
					opacity: 0;
					bottom: -3rem;
				`;

				var inner = document.createElement('div');
				inner.style.cssText = `
					pointer-events: none;
					user-select: none;
					font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
					font-size: 1rem;
					padding: 0.5rem;
					line-height: calc(1rem - 0.2rem);
					box-sizing: border-box;
					background-color: white;
					border: 0.1rem solid #77f;
					color: #77f;
					font-weight: bold;
					text-align: center;
					margin-left: auto;
					margin-right: auto;
				`;
				inner.textContent = text;

				element.appendChild(inner);
				document.body.appendChild(element);

				// Wait & show
				getComputedStyle(element).opacity;
				element.style.bottom = '1rem';
				element.style.opacity = '1';

				// Appear + visible delay
				setTimeout(function() {
					// Make transparent and hide
					element.style.bottom = '-3rem';
					element.style.opacity = '0';

					setTimeout(function() {
						// Dispose
						document.body.removeChild(element);
					}, appearDuration * 1000);
				}, appearDuration * 1000 + duration * 1000);
			}

			function saget(url) {
				return new Promise((resolve, reject) => {
					fetch(url)
					.then((response) => {
						if (response.status != 200) {
							reject({
								'status': 'error',
								'message': response.statusText
							});
							return;
						} else
							return response.json();
					})
					.then((data) => {
						if (data === undefined)
							reject({ status: 'error', message: 'empty response' });
						else if (data['status'] != 'result')
							reject(data);
						else
							resolve(data);
					})
					.catch((error) => {
						reject(error);
					})
				});
			};

			function htmlToElement(html) {
				var template = document.createElement('template');
				html = html.trim();
				template.innerHTML = html;
				return template.content.firstChild;
			};

			function fetchConfig() {
				return new Promise((resolve, reject) => {
					window.config = window.config ?? {};
					if (!(window.config && window.config.password)) {
						if (getCookie('password') === null) {
							setCookie('password', '');
							window.config['password'] = '';
						} else {
							window.config['password'] = getCookie('password');
						}
					}

					saget(`/config?password=${ encodeURIComponent(window.config['password']) }&action=get`)
					.then(async (data) => {
						resolve(window.config = data.config);
					})
					.catch((error) => {
						console.error(error);
						showToast(error.message, 1, 1);
						reject(error);
					});
				});
			}

			function hideConfigDialog() {
				document.getElementById('dialog').style.display='none';
				// startFetchLoop();
				startWorkerLoop();
			}

			async function showConfigDialog() {
				// stopFetchLoop();
				
				stopWorkerLoop();

				// await fetchConfig()
				// .then(() => {})
				// .catch(() => {});

				document.getElementById('dialog').style.display=null;
				var form = document.getElementById('form');
				form.innerHTML = '';

				for (const [key, value] of Object.entries(get_props())) {
					var element = htmlToElement(`
					<div class="input-field">
						<label>${ key }</label>
						<div>
							<input type="text" value="${ value }" id="input-${ key }">
							<input type="button" value="set" id="submit-${ key }">
						</div>
					</div>`);

					form.appendChild(element);
					document.querySelector(`#submit-${ key }`).addEventListener('click', function() {
						let newValue = document.querySelector(`#input-${ key }`).value.trim();
						set_prop(key, newValue);
						showToast(`Set value for ${ key }`, 1, 1);
					});
				}
			}

			function stopFetchLoop() {
				window.fetchLoopRunning = window.fetchLoopRunning ?? false;
				if (window.fetchLoopRunning) {
					window.fetchLoopRunning = false;
					window.remoteSocketTs = 0;
				}
			}

			function startFetchLoop() {
				// Clear old
				window.fetchLoopRunning = window.fetchLoopRunning ?? false;
				stopFetchLoop();

				// Is started at least one loop
				window.fetchLoopRunning = true;

				// Delay steps
				var frameDelay = 1000.0 / (window.config.fps ?? 1);
				var inputDelay = 1000.0 / (window.config.ips ?? 1);

				// Last mouse vent time
				var lastMouseTs = -1;

				var connectToRemote = function() {

					// Current socket timestamp, prevent stacking
					var remoteSocketTs = window.remoteSocketTs = Date.now();

					// Create socket for frames stream
					var remoteSocket = null;
					var frames_received = 0;

					var closeConnection = function() {
						if (remoteSocket !== null) {
							try { remoteSocket.close(); } catch {}
							remoteSocket = null;

							// Info
							showToast('Connection closed', 1, 1);

							// Restart
							if (window.fetchLoopRunning && remoteSocketTs === window.remoteSocketTs)
								connectToRemote();
						}
					};

					// Receive frames from server
					var frame_worker = function(msg) {
						var url = URL.createObjectURL(msg.data);
						var frame = new Image();
						frame.onload = function() {
							URL.revokeObjectURL(url);

							window.canvasContext.drawImage(
								frame,
								canvas.width / 2 - frame.width / 2,
								canvas.height / 2 - frame.height / 2
							);

							// Update remote viewbox
							window.viewbox.width = frame.width;
							window.viewbox.height = frame.height;

							// Send ACK
							try {
								remoteSocket.send('FA');
							} catch {}

							++frames_received;
						};
						frame.src = url;

						// Close connection on stop / disconnect
						if (remoteSocketTs !== window.remoteSocketTs) {
							closeConnection();
						}
					};

					// Send input state & check open status
					var input_worker = function(msg) {

						// Close on socket update
						if (remoteSocketTs !== window.remoteSocketTs) {
							closeConnection();
							return;
						} else if (remoteSocket === null) {
							return;
						}

						// Update viewport
						if (canvas.width != window.innerWidth || canvas.height != window.innerHeight) {
							canvas.width = window.innerWidth;
							canvas.height = window.innerHeight;

							// Update props for view
							window.lineHeight = window.getComputedStyle(document.body).lineHeight;
							window.pageHeight = window.clientHeight;

							saget(`/config?password=${ encodeURIComponent(window.config['password']) }&action=set&key=width&value=${ canvas.width }`)
							.then((data) => {})
							.catch((error) => {
								showToast(error.message, 1, 1);
							});

							saget(`/config?password=${ encodeURIComponent(window.config['password']) }&action=set&key=height&value=${ canvas.height }`)
							.then((data) => {})
							.catch((error) => {
								showToast(error.message, 1, 1);
							});
						}

						// Send mouse location
						if (window.inputEvents.length !== 0 && frames_received !== 0) {
							try {
								let events = window.inputEvents;
								window.inputEvents = [];
								remoteSocket.send(JSON.stringify(events));
							} catch {}
						}

						setTimeout(input_worker, inputDelay);
					};

					// Receive only
					console.info('connect to', `${ window.location.protocol === 'https:' ? 'wss' : 'ws' }://${ window.location.host }/connect_ws`)
					remoteSocket = new WebSocket(`${ window.location.protocol === 'https:' ? 'wss' : 'ws' }://${ window.location.host }/connect_ws?password=${ encodeURIComponent(window.config['password']) }`);
					remoteSocket.onmessage = frame_worker;
					remoteSocket.onopen = input_worker;
					remoteSocket.onclose = closeConnection;
				};

				connectToRemote();
			}

			function startInputLoop() {

				// Input handler
				var lastMouseMoveTs = Date.now();
				var mouseMove = function(event) {
					// Fire only inside viewbox & with throttling to ips x 2
					if (window.viewbox.width === 0 || window.viewbox.height === 0 || Date.now() - lastMouseMoveTs <= 1000.0 / (window.config.ips ?? 1) || window.inputEvents.length > window.config.ips * 2)
						return;

					let rectX = (window.canvas.clientWidth / 2) - (window.viewbox.width / 2);
					let rectY = (window.canvas.clientHeight / 2) - (window.viewbox.height / 2);

					if (
						event.pageX >= rectX && event.pageX <= rectX + window.viewbox.width &&
						event.pageY >= rectY && event.pageY <= rectY + window.viewbox.height
						) {
							window.inputEvents.push([
								INPUT_EVENT_MOUSE_MOVE,
								event.pageX - rectX,
								event.pageY - rectY
							]);
						lastMouseMoveTs = Date.now();
					}
				};

				// Update props for view
				window.lineHeight = window.getComputedStyle(document.body).lineHeight;
				window.pageHeight = window.clientHeight;

				// Input handler
				var lastMouseScrollTs = Date.now();
				var mouseScroll = function(event) {
					// Fire only inside viewbox & with throttling to ips x 2
					if (window.viewbox.width === 0 || window.viewbox.height === 0 || Date.now() - lastMouseScrollTs <= 1000.0 / (window.config.ips ?? 1) || window.inputEvents.length > window.config.ips * 2)
						return;

					let rectX = (window.canvas.clientWidth / 2) - (window.viewbox.width / 2);
					let rectY = (window.canvas.clientHeight / 2) - (window.viewbox.height / 2);

					if (
						event.pageX >= rectX && event.pageX <= rectX + window.viewbox.width &&
						event.pageY >= rectY && event.pageY <= rectY + window.viewbox.height
						) {
							// Add event
							window.inputEvents.push([
								INPUT_EVENT_MOUSE_SCROLL,
								event.pageX - rectX,
								event.pageY - rectY,
								-event.deltaY
							]);
						lastMouseScrollTs = Date.now();
					}
				};

				// Input handler
				var mouseDown = function(event) {
					// Stop event
					event.preventDefault();
					event.stopPropagation();

					// Check
					if (window.viewbox.width === 0 || window.viewbox.height === 0)
						return;

					let rectX = (window.canvas.clientWidth / 2) - (window.viewbox.width / 2);
					let rectY = (window.canvas.clientHeight / 2) - (window.viewbox.height / 2);

					if (
						event.pageX >= rectX && event.pageX <= rectX + window.viewbox.width &&
						event.pageY >= rectY && event.pageY <= rectY + window.viewbox.height
					) {
						window.inputEvents.push([
							INPUT_EVENT_MOUSE_DOWN,
							event.pageX - rectX,
							event.pageY - rectY,
							event.button,
						]);
					}
				};

				// Input handler
				var mouseUp = function(event) {
					// Stop event
					event.preventDefault();
					event.stopPropagation();

					// Check
					if (window.viewbox.width === 0 || window.viewbox.height === 0)
						return;

					let rectX = (window.canvas.clientWidth / 2) - (window.viewbox.width / 2);
					let rectY = (window.canvas.clientHeight / 2) - (window.viewbox.height / 2);

					window.inputEvents.push([
						INPUT_EVENT_MOUSE_UP,
						event.pageX - rectX,
						event.pageY - rectY,
						event.button,
					]);
				};

				// Register listeners
				window.canvas.addEventListener('mousemove', mouseMove);
				window.canvas.addEventListener('wheel', mouseScroll);
				window.canvas.addEventListener('mousedown', mouseDown);
				window.canvas.addEventListener('mouseup', mouseUp);
				window.canvas.addEventListener('contextmenu', function(event) { event.preventDefault(); event.stopPropagation();  false; });
			}

			
			
			
			
			
			function decode_int8(data, off) {
				return data[off];
			}
			
			function decode_int16(data, off) {
				return data[off] | (data[off + 1] << 8);
			}
			
			function decode_int24(data, off) {
				return data[off] | (data[off + 1] << 8) | (data[off + 2] << 16);
			}
			
			function encode_int8(i, arr, off) {
				arr[off] = i & 0xff;
			}
			
			function encode_int16(i, arr, off) {
				arr[off] = i & 0xff;
				arr[off + 1] = (i >> 8) & 0xff;
			}
			
			function encode_int24(i, arr, off) {
				arr[off] = i & 0xff;
				arr[off + 1] = (i >> 8) & 0xff;
				arr[off + 2] = (i >> 16) & 0xff;
			}
			
			
			
				
			// Default props
			const DEFAULTS = {
				'password': '',
				'quality': 75,
				'fps': 20,
				'ips': 5
			};
			
			var props = null;
			
			// Init default or stored props values
			function init_props() {
				props = { ...DEFAULTS };
				
				try {
					var localProps = JSON.parse(localStorage.getItem('httprd-props'));
					for (const [key, _] of Object.entries(props)) {
						var v = localProps[key];
						if (v)
							props[key] = v;
					}
				} catch {}
			};
			
			function get_prop(name) {
				return props[name];
			};
			
			function get_props() {
				return props;
			}
			
			function set_prop(name, value) {
				if (name === 'password') {
					value = value.trim();
				} else if (name === 'quality') {
					try {
						value = parseInt(value);
					} catch (e) {
						throw new Error('quality must be in range [1, 100]');
					}
					
					if (value < 1 || value > 100)
						throw new Error('quality must be in range [1, 100]');
				} else if (name === 'fps') {
					try {
						value = parseInt(value);
					} catch (e) {
						throw new Error('fps must be in range [1, inf]');
					}
					
					if (value < 1)
						throw new Error('fps must be in range [1]');
				} else if (name === 'ips') {
					try {
						value = parseInt(value);
					} catch (e) {
						throw new Error('ips must be in range [1, inf]');
					}
					
					if (value < 1)
						throw new Error('ips must be in range [1]');
				}
				
				props[name] = value;
				localStorage.setItem('httprd-props', JSON.stringify(props));
			};
			
			
			var remoteSocket = null;
			window.workerLoopRunning = false;
			
			function stopWorkerLoop() {
				console.info('stopWorkerLoop() : stopping loop');
				
				window.workerLoopRunning = false;
				
				try {
					if (window.workerLoopTs) {
						window.workerLoopTs = null;
						remoteSocket.close();
					}
				} catch (e) {
					console.error(e);
				}
			}
			
			
			function get_prop(name) {
				if (props === null) {
					// Request
					// requestProps();
					
					// Default
					return DEFAULTS[name];
				} else
					return props[name];
			};
			
			function startWorkerLoop() {
				console.info('startWorkerLoop() : starting loop');
				
				// Stop existing loop
				var loopTs = Date.now();
				if (window.workerLoopTs && loopTs > window.workerLoopTs) 
					stopWorkerLoop();
				window.workerLoopTs = loopTs;
				window.workerLoopRunning = true;
				
				// Check if loop is still running
				function checkLoop() {
					return loopTs == window.workerLoopTs;
				}
				
				var requestFrame = function() {
					var requestFrame__buffer = new Uint8Array(1 + 2 + 2 + 1);
					console.info('requestFrame() : requesting frame');
					
					// Skip if loop is closed
					if (!checkLoop())
						return;
					
					try {
						// Send packet type
						encode_int8(0x01, requestFrame__buffer, 0);
						
						// Send width & height					
						let viewport_width = Math.max(Math.min(window.innerWidth, 65535), 1);
						let viewport_height = Math.max(Math.min(window.innerHeight, 65535), 1);
						let quality = Math.max(Math.min(get_prop('quality'), 100), 1);
						encode_int16(viewport_width, requestFrame__buffer, 1);
						encode_int16(viewport_height, requestFrame__buffer, 3);
						encode_int8(quality, requestFrame__buffer, 5);
					
						// Actually, send
						remoteSocket.send(requestFrame__buffer.buffer)
					} catch (e) {
						console.error(e);
					}
				};
				
				function msg_handler(msg) {
					// console.info('msg_handler() : processing msg');
					
					if (msg.data instanceof ArrayBuffer) {
						var data = new Uint8Array(msg.data);
						var packet_type = decode_int8(data, 0);
						
						console.info(`msg_handler() : packet_type = ${ packet_type }`);
						
						// Frame
						if (packet_type == 0x02) {
							// console.info('msg_handler() : processing frame');
							
							try {
								var blob = new Blob([ data.slice(1) ], { type: 'image/jpeg' });
								var url = URL.createObjectURL(blob);
								
								// Deallocate
								delete blob;
								
								var frame = new Image();
								frame.onload = function() {
									URL.revokeObjectURL(url);
									
									// Resize canvas
									if (canvas.width != window.innerWidth || canvas.height != window.innerHeight) {
										canvas.width = window.innerWidth;
										canvas.height = window.innerHeight;
									}

									window.canvasContext.drawImage(
										frame,
										canvas.width / 2 - frame.width / 2,
										canvas.height / 2 - frame.height / 2
									);

									// Update remote viewbox
									window.viewbox.width = frame.width;
									window.viewbox.height = frame.height;

									// Release
									delete frame;
									
									// Re-request new frame in interval
									setTimeout(requestFrame, 1000.0 / get_prop('fps'));
								};
								frame.src = url;
							} catch (e) {
								console.error(e);
								
								// Re-request new frame in interval as failed
								setTimeout(requestFrame, 1000.0 / get_prop('fps'));
							}
						}
						
						// Deallocate
						delete data;
					}
				};
				
				function open_handler(event) {
					console.info('open_handler() : started loop');
				
					// Periodic frame poll
					setTimeout(requestFrame, 1000.0 / get_prop('fps'));
				};
				
				function close_handler(event) {
					console.info('close_handler() : stopping loop');
					
					// Reconnect if loop was not terminated externally
					if (window.workerLoopRunning) {
						showToast('Connection closed', 1, 1);
						startWorkerLoop();
					}
				};
				
				console.info('connect to', `${ window.location.protocol === 'https:' ? 'wss' : 'ws' }://${ window.location.host }/connect_ws`)
				remoteSocket = new WebSocket(`${ window.location.protocol === 'https:' ? 'wss' : 'ws' }://${ window.location.host }/connect_ws?password=${ encodeURIComponent(get_prop('password')) }`);
				remoteSocket.binaryType = 'arraybuffer';
				remoteSocket.onmessage = msg_handler;
				remoteSocket.onopen = open_handler;
				remoteSocket.onclose = close_handler;
			}
			
			(async function() {
				window.canvas = document.getElementById('display');
				window.canvasContext = window.canvas.getContext('2d');

				// Input events buffer
				window.inputEvents = [];

				// Viewbox size
				window.viewbox = { width: 0, height: 0 };

				// Init config
				init_props()
				
				// Start loops
				startWorkerLoop();
				// startFetchLoop();
				// startInputLoop();
			}) ();
		</script>
	</body>
</html>
